#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/resource.h>
#include <errno.h>
#include "utils.h"




void print_error(const char *err) {

    printf(" \n\n Error: %s \n\n ", err);
    fflush(NULL);
    exit(1);
}


void free_instance(instance *inst) {

    free(inst->table_sm1);
    free(inst->table_sm2);
    free(inst->table_sm3);
    free(inst->table_sm5);
    free(inst->table_sm6);

}

void debug() {

    printf("Debug \n");
}


/*
 * Return the ambient temperature given a time t
 */
double ambientTemperatureAtTimet(int t, instance *inst) {

    double temperature = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_amb_temp_intervals; i++) {
        if ( t >= inst->table_sm9[i].start_interval && t <= inst->table_sm9[i].end_interval )
            temperature = inst->table_sm9[i].temperature;
    }
    return temperature;

}

double externalTemperatureAtTimet(instance *inst, int t){

    double temperature = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_outdoor_temperature_intervals; i++) {
        if ( t >= inst->table_sm11[i].start_interval && t <= inst->table_sm11[i].end_interval )
            temperature = inst->table_sm11[i].outdoor_temperature;
    }
    return temperature;
}


/*
 * Return the water withdrawl a time t
 */
double waterWithdrawlAtTimet(int t, instance *inst){

    double ww = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_waterwithdrawl_intervals; i++) {
        if ( t >= inst->table_sm8[i].start_interval && t <= inst->table_sm8[i].end_interval )
            ww = inst->table_sm8[i].kg_water;
    }
    return ww;
}


/*
 * Return the price associated at the power level l provided
 */
double powerLevelCost(int l, instance *inst) {

    double cost = inst->table_sm2[l-1].price_at_day;
    //printf("Costo : %lf ", cost);
    return cost;
}



double powerCostTimet(int t, instance *inst) {

    double cost = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_subperiods; i++) {
        if ( t >= inst->table_sm1[i].start_interval && t <= inst->table_sm1[i].end_interval )
            cost = inst->table_sm1[i].price_subperiod;
    }
    return cost;
}

/*
 * Power required by the base load in table 3
 */
double baseLoadAtTime(int t, instance *inst) {

    double power = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_baseloadintervals; i++) {
        if ( t >= inst->table_sm3[i].start_interval && t <= inst->table_sm3[i].end_interval )
            power = inst->table_sm3[i].power_required;
    }
    return power;
}

/*
 * Power generated by the PV units in table 4
 */
double pvGenerationAtTime(int t, instance *inst) {

    double power = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_pvgeneration_intervals; i++) {
        if ( t >= inst->table_sm4[i].start_interval && t <= inst->table_sm4[i].end_interval )
            power = inst->table_sm4[i].generated_power;
    }
    return power;
}


/*
 * Power required by the shiftable load j at its stage r
 */
int powerRequiredShiftableStageR(instance *inst, int j, int r) {

    int time_interval = inst->MAX_DJ / inst->nof_appliancestages;   //15
    int integer_part = r / time_interval;
    int power_at_stage_r = 0;
    switch (integer_part)
    {
        case 0:
            power_at_stage_r = inst->table_sm6[j].power_first_interval;
        break;
        case 1:
            power_at_stage_r = inst->table_sm6[j].power_second_interval;
        break;
        case 2:
            power_at_stage_r = inst->table_sm6[j].power_third_interval;
        break;
        case 3:
            power_at_stage_r = inst->table_sm6[j].power_fourth_interval;
        break;
        case 4:
            power_at_stage_r = inst->table_sm6[j].power_fifth_interval;
        break;
        case 5:
            power_at_stage_r = inst->table_sm6[j].power_sixth_interval;
        break;
        case 6:
            power_at_stage_r = inst->table_sm6[j].power_seventh_interval;
        break;
    }

    return power_at_stage_r;
}

#define CLOCK_MONOTONIC                 1

double seconds() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (double) ts.tv_sec + 1.0e-9 * ((double) ts.tv_nsec);
    return ((double) clock() / (double) CLOCKS_PER_SEC);
}














