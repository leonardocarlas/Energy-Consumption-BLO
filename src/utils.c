#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/resource.h>
#include <errno.h>
#include "utils.h"




void print_error(const char *err) {

    printf(" \n\n Error: %s \n\n ", err);
    fflush(NULL);
    exit(1);
}


void free_instance(instance *inst) {

    free(inst->table_sm1);
    free(inst->table_sm2);
    free(inst->table_sm3);
    free(inst->table_sm5);
    free(inst->table_sm6);

}

void debug() {

    printf("Debug \n");
}


/*
 * Return the ambient temperature given a time t
 */
double ambientTemperatureAtTimet(int t, instance *inst) {

    double temperature = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_amb_temp_intervals; i++) {
        if ( t >= inst->table_sm9[i].start_interval && t <= inst->table_sm9[i].end_interval )
            temperature = inst->table_sm9[i].temperature;
    }
    return temperature;

}

double externalTemperatureAtTimet(instance *inst, int t){

    double temperature = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_outdoor_temperature_intervals; i++) {
        if ( t >= inst->table_sm11[i].start_interval && t <= inst->table_sm11[i].end_interval )
            temperature = inst->table_sm11[i].outdoor_temperature;
    }
    return temperature;
}


/*
 * Return the water withdrawl a time t
 */
double waterWithdrawlAtTimet(int t, instance *inst){

    double ww = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_waterwithdrawl_intervals; i++) {
        if ( t >= inst->table_sm8[i].start_interval && t <= inst->table_sm8[i].end_interval )
            ww = inst->table_sm8[i].kg_water;
    }
    return ww;
}




/*
 * Return the price associated at the power level l provided
 */
double powerLevelCost(int l, instance *inst) {

    double cost = inst->table_sm2[l-1].price_at_day;
    //printf("Costo : %lf ", cost);
    return cost;
}



double powerCostTimet(int t, instance *inst) {

    double cost = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_subperiods; i++) {
        if ( t >= inst->table_sm1[i].start_interval && t <= inst->table_sm1[i].end_interval )
            cost = inst->table_sm1[i].price_subperiod;
    }
    return cost;
}

double powerSellTimet(int t, instance *inst) {

    double cost = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_subperiods; i++) {
        if ( t >= inst->table_sm1[i].start_interval && t <= inst->table_sm1[i].end_interval )
            cost = inst->table_sm1[i].sell_price_subperiod;
    }
    return cost;
}

/*
 * Power required by the base load in table 3
 */
double baseLoadAtTime(int t, instance *inst) {

    double power = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_baseloadintervals; i++) {
        if ( t >= inst->table_sm3[i].start_interval && t <= inst->table_sm3[i].end_interval )
            power = inst->table_sm3[i].power_required;
    }
    return power;
}

/*
 * Power generated by the PV units in table 4
 */
double pvGenerationAtTime(int t, instance *inst) {

    double power = 0.0;
    t = t + 1;
    for (int i = 0; i < inst->nof_pvgeneration_intervals; i++) {
        if ( t >= inst->table_sm4[i].start_interval && t <= inst->table_sm4[i].end_interval )
            power = inst->table_sm4[i].generated_power;
    }
    return power;
}


/*
 * Power required by the shiftable load j at its stage r
 */
int powerRequiredShiftableStageR(instance *inst, int j, int r) {

    int time_interval = inst->MAX_DJ / inst->nof_appliancestages;   //15
    int integer_part = r / time_interval;
    int power_at_stage_r = 0;
    switch (integer_part)
    {
        case 0:
            power_at_stage_r = inst->table_sm6[j].power_first_interval;
        break;
        case 1:
            power_at_stage_r = inst->table_sm6[j].power_second_interval;
        break;
        case 2:
            power_at_stage_r = inst->table_sm6[j].power_third_interval;
        break;
        case 3:
            power_at_stage_r = inst->table_sm6[j].power_fourth_interval;
        break;
        case 4:
            power_at_stage_r = inst->table_sm6[j].power_fifth_interval;
        break;
        case 5:
            power_at_stage_r = inst->table_sm6[j].power_sixth_interval;
        break;
        case 6:
            power_at_stage_r = inst->table_sm6[j].power_seventh_interval;
        break;
    }

    return power_at_stage_r;
}

/*
 * Return a random price between a minimum and a maximum of the sub period
 */
double randomPrice(int i, instance *inst){

    double price = 0.0;
    double min = inst->table_sm1[i].min_price;
    double max = inst->table_sm1[i].max_price;
    price = min + (max - min) * (double) rand() / RAND_MAX;
    return price;

}

/**
 * Return a value between in the interval [0,1]
 * @return
 */
double randomValue01(){

    double n = 0.0;
    double min = 0.0;
    double max = 1;
    n = min + (max - min) * (double) rand() / RAND_MAX;
    return n;

}


double randomPerturbation(int i, instance *inst, double DELTA){

    double price = 0.0;
    double min = - DELTA * ( inst->table_sm1[i].max_price - inst->table_sm1[i].min_price);
    double max =   DELTA * ( inst->table_sm1[i].max_price - inst->table_sm1[i].min_price);
    price = min + (max - min) * (double) rand() / RAND_MAX;
    return price;
}


double randomNeighbour(int i, instance *inst, double current_value){

    double price = 0.0;
    double amplitudePi = inst->table_sm1[i].max_price - inst->table_sm1[i].min_price;
    double unite = amplitudePi / 100;
    double eps = 3 * unite;
    double min = current_value - eps;
    double max = current_value + eps;
    price = min + (max - min) * (double) rand() / RAND_MAX;
    return price;
}

/*
 * Return a random sub period
 */
int randomSubperiod(instance *inst){

    int min = 1;
    int max = inst->nof_subperiods;
    int subPeriod = min + (max - min) * (double) rand() / RAND_MAX;
    return subPeriod;

}

void sortingSolutions(int *indexesVector, double *valuesVector, int N){

    int max;
    double t; // values exchange
    int s; // index exchange

    //t è la variabile temporanea utilizzata per lo scambio

    for (int i = 0; i < N - 1; ++i) {

        max = i;
        for (int j = i+1; j < N; ++j) {
            if ( valuesVector[j] > valuesVector[max] )
                max = j;
        }
        // Scambio i valori, si trova l'elemento più piccolo dell'array e si scambia con l'elemento alla posizione i
        t = valuesVector[max];
        valuesVector[max] = valuesVector[i];
        valuesVector[i] = t;

        // Scambio gli indici
        s = indexesVector[max];
        indexesVector[max] = indexesVector[i];
        indexesVector[i] = s;

    }
}


int randomNewIndividual(int m){

    int min = 1;
    int max = m;
    int chosen = min + (max - min) * (double) rand() / RAND_MAX;
    return chosen;

}



int maxObjvalue(double * values, int n){

    int max_ind = 0;
    double max = 0.0;
    for (int i = 0; i < n; ++i) {
        if (values[i] > max ){
            max_ind = i;
            max = values[i];
        }

    }
    return max_ind;
}



#define CLOCK_MONOTONIC                 1

double seconds() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (double) ts.tv_sec + 1.0e-9 * ((double) ts.tv_nsec);
    return ((double) clock() / (double) CLOCKS_PER_SEC);
}














